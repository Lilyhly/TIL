Lv4

这段代码使用了面向对象编程的思想，通过创建抽象类 AbstractOperation 和其子类（AddOperation、SubtractOperation、MultiplyOperation、DivideOperation）来表示不同的操作。然后，通过 Calculator 类来进行操作的选择和计算。

让我们逐步解释为什么设计成这样：

AbstractOperation 抽象类：
通过创建抽象类，可以定义一个通用的操作接口，确保每个具体操作类都要实现 operate 方法。
operate 方法返回 Double 类型，因为这样可以支持更广泛的操作类型，包括可能生成小数的操作。
具体操作类（AddOperation、SubtractOperation、MultiplyOperation、DivideOperation）：
每个具体操作类都继承自 AbstractOperation，并实现了 operate 方法，以定义特定的操作。
每个操作类都能返回执行操作后的结果。
Calculator 类：
Calculator 类包含一个抽象操作类的实例变量 abstractOperation，表示当前选择的操作。
通过 setOperation 方法，可以在运行时更改选择的操作。
calculate 方法用于执行当前选择的操作，并返回结果。
这种设计允许灵活地切换和扩展不同的操作，而不需要修改 Calculator 类的代码。例如，如果要添加新的操作，只需创建一个新的具体操作类并将其设置为当前操作即可，而不必修改 Calculator 的实现。这符合面向对象编程中的开闭原则，即对扩展开放，对修改关闭。

Lv4 跟 Lv3的比較
这两个代码片段的主要区别在于设计模式和代码组织的方式。

第一个代码片段（使用抽象类和委托）：
使用了抽象类 AbstractOperation，其中定义了 operate 方法，子类需要实现该方法。
Calculator 类包含一个抽象操作类的实例变量，通过委托给具体的操作类执行操作。
通过操作类的切换，支持更灵活的操作扩展。
第二个代码片段（使用各个具体操作类）：
没有使用抽象类，而是直接创建了各个具体的操作类。
Calculator 类包含了各个具体操作类的实例变量，并通过判断运算符选择相应的操作类执行操作。
区别总结：
可扩展性： 第一个代码片段通过抽象类和委托的方式更加灵活，支持轻松添加新的操作类。第二个代码片段则需要在 Calculator 类中添加新的实例变量和判断条件，相对较为繁琐。
代码复用： 第一个代码片段中，如果有其他类似的计算器，可以轻松地使用相同的抽象类和操作类，达到代码复用。而第二个代码片段每个计算器都需要重复创建各个具体操作类的实例。
单一职责原则： 第一个代码片段中，每个类都有一个单一职责，分别负责操作和计算器。而第二个代码片段中，Calculator 类负责了选择和执行操作，违反了单一职责原则。
总的来说，第一个代码片段使用了更灵活的设计，更符合一些设计原则，而第二个代码片段则更为直接，适用于简单的场景。选择使用哪种设计取决于具体需求和可维护性的考虑。
